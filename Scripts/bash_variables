------------------------------  Setting an reading ----------------------------------
A variable in bash can contain a number, a character, a string of characters.
There are no data types for bash variables. 
When referring to or reading a variable we place a $ sign before the variable name.
Bash is a case sensitive environment so variables are case-sensitive.

When setting a variable we leave out the $ sign.
When setting a variable there is NO SPACE on either side of the equals ( = ) sign. 

Bash will replace the variable with the value of it before the command or script is run.
Single quotes will treat every character literally.
Double quotes will allow you to do substitution (that is include variables within the setting of the value).
Local variables can be created by using the keyword local.


------------------------------  Command substitution ----------------------------------
Command substitution '$( xxx )' allows us to take the output of a command and save it as the value of a variable. 
If the output of command substitution goes over several lines then the newlines are simply removed 
    and all the output ends up on a single line.


------------------------------   Exporting variables ----------------------------------
Variables are limited to the process they were created in. 
If we want the variable to be available to the second script then we need to export the variable.
Exporting just makes a copy of the variable and hand it over to the new process. 
Anything that the new process does with the copy of the variables has no impact on the original variables.

----------------------------------  Examples -------------------------------------------
$ myvar='Hello World'
$ echo $myvar
Hello World
$ newvar="More $myvar"
$ echo $newvar
More Hello World
$ newvar='More $myvar'
$ echo $newvar
More $myvar

$ myvar=$( ls /etc | wc -l )
$ echo There are $myvar entries in the directory /etc

#!/bin/bash          
OF=/var/my-backup-$(date +%Y%m%d).tgz
tar -cZf $OF /home/me/

$ ls
bin Documents Desktop ...
Downloads public_html ...
$ myvar=$( ls )
$ echo $myvar
bin Documents Desktop Downloads public_html ...


---------------------------  special variables -------------------------------------------
$0 - The name of the Bash script.
$1 - $9 - The first 9 arguments to the Bash script. 
$# - How many arguments were passed to the Bash script.

$@ - All the arguments supplied to the Bash script.
"$@" is an array-like construct of all positional parameters, {$1, $2, $3 ...}.
"$*" is the IFS expansion of all positional parameters, $1 $2 $3 ....
$* / $@ list of arguments passed to script as string / delimited list

$? - The exit status of the most recently run process.
$$ - The process ID of the current script.
$USER - The username of the user running the script.
$HOSTNAME - The hostname of the machine the script is running on.
$SECONDS - The number of seconds since the script was started.
$RANDOM - Returns a different random number each time is it referred to.
$LINENO - Returns the current line number in the Bash script.

$# is the number of positional parameters.
$- current options set for the shell.
$_ most recent parameter (or the abs path of the command to start the current shell immediately after startup).
$IFS is the (input) field separator.
$! is the PID of the most recent background command.


------------------------------------------- !$ vs $_ -----------------------------------------------------------
Q:
        $ echo "hello" > /tmp/a.txt
        $ echo "!$"
        echo "/tmp/a.txt"
        /tmp/a.txt

        $ echo "hello" > /tmp/a.txt
        $ echo $_
        hello

A: 
!$ is a word designator of history expansion, it expands to the last word of previous command in history. 
IOW, the last word of previous entry in history. This word is usually the last argument to command, 
but not in case of redirection. In:

$ echo "hello" > /tmp/a.txt
the whole command 'echo "hello" > /tmp/a.txt' appeared in history, and /tmp/a.txt is the last word of that command.

_ is a shell parameter, it expands to last argument of previous command. 
Here, the redirection is not a part of arguments passed to the command, so only hello is the argument passed to echo. 
That's why $_ expanded to hello.

_ is not one of shell standard special parameters anymore. It works in bash, zsh, mksh and dash only when interactive, 
ksh93 only when two command are on separated lines:

$ echo 1 && echo $_
1
/usr/bin/ksh

$ echo 1
1
$ echo $_
1
----------------------------------------------------------------------------------------------------------------



More information:
https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php
