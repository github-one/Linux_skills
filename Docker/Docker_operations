More information:
http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html                                         # simple introduction
https://www.infoq.cn/article/docker-network-and-pipework-open-source-explanation-practice           # docker network

----------------------------------------------  Docker Conceptions ----------------------------------------------------------------
Images Default Command:
    Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。
    Dockerfile中的CMD 指令就是用于指定默认的容器主进程的启动命令的。
    例1: ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。
    在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，
    输出了系统版本信息。
    例2：alpine 镜像默认的CMD是 /bin/sh
    You can check the default command by "$ docker history <images_name>"

前台和后台执行问题：
    提到CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。
    Docker不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，
    ===容器内没有后台服务的概念===

Running a Service in a Docker:
    一些初学者将 CMD 写为：
    CMD service nginx start
    然后发现容器执行后就立即退出了。甚至在容器内去使用systemctl命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，
    没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。
    对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是
    它需要关心的东西。
    而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为
    CMD [ "sh", "-c", "service nginx start"]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，
    sh 作为主进程退出了，自然就会令容器退出。

    正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：
    CMD ["nginx", "-g", "daemon off;"]
    说明：可以通过"$ docker history nginx"查看到官方nginx镜像的默认命令就是这个。


----------------------------------------------  Docker Operations ----------------------------------------------------------------
Docker Running
    $ docker container start            # start the container that has already exists.
    $ docker container run              # create a new container every time.
    $ docker container stop             # send SIGTERM signal, then send SIGKILL signal after a while.
    $ docker container kill             # send SIGKILL signal to the process at once.
    $ docker container logs             # look up the output of the container shell
    # docker container exec             # enter a running container
    $ docker container cp [containerID]:[/path/to/file] .
   
   
docker attach vs exec
    "docker attach" isn't for running an extra thing in a container, it's for attaching to the running process.
    "docker exec" is specifically for running new things in a already started container, be it a shell or some other process.
    (docker >= 1.3) If we use "docker attach", we can use only one instance of shell. So if we want open new terminal 
    with new instance of container's shell, we just need run "docker exec".   
    If the docker container was started using "/bin/bash" command, you can access it using "docker attach", if not then 
    you need to execute the command to create a bash instance inside the container using "docker exec".


Docker Options
    --rm
    Running containers with --rm flag is good for thoses containers that you use for very short while just to accomplish something, 
    e.g. , compile your application inside a container, or jsut testing something that it works, and then you know its a short lived
    container and you tell your Docker daemon that once its done running, erease everything related to it and save the disk space.
    
    By default a container's file system persists even after the container exits. This makes debugging a lot easier(since you can 
    inspect the final state) and you retain all your data by defualt. But if you are running short-term foreground processes, 
    these container file systems can really pile up. If instead you'd like Dokcer to automatically clean up the container and 
    remove the file system when the container exits, you can add the --rm flag.


Docker Network
    $ docker inspect <container_name_or_ID>
    $ docker inspect <container_name_or_ID> | grep '"IPAddress"' | head -n 1
    $ docker inspect -f "{{.NetworkSettings.IPAddress}}" <contain_name_or_ID>
    $ docker inspect -f '{{.NetworkSettings.IPAddress}}' $(docker ps -aq)
    
    $ cat /etc/hosts
    $ cat /etc/resolv.conf              # looking up the DNS configuration
    $ cat /etc/nsswitch.conf            # looking up the hosts name configuration
    
    $ ip addr show
    $ ip route show
    $ netstat -nr       # looking up the IP forwarding table
    $ iptables -L -v
    

----------------------------------------------  Docker FAQs ----------------------------------------------------------------
Q:  How to start a stopped Docker container with a different command?
    I would like to start a stopped Docker container with a different command, as the default command crashes - meaning 
    I can't start the container and then use 'docker exec'. 
    Basically I would like to start a shell so I can inspect the contents of the container.
    Luckily I created the container with the -it option!
    
A:  Find your stopped container id
    $ docker ps -a
    Commit the stopped container:
    This command saves modified container state into a new image user/test_image

    $ docker commit $CONTAINER_ID user/test_image
    Start/run with a different entry point:
    $ docker run -ti --entrypoint=sh user/test_image
    
    Note:
    Steps above just start a stopped container with the same filesystem state. That is great for a quick investigation. 
    But environment variables, network configuration, attached volumes and other staff is not inherited, you should 
    specify all these arguments explicitly.
    
    
