|| assignment
    In Perl, you can use the ||= operator. Its precedence rules are such that it’ll only do an assignment if the value is false 
    (‘false’ generally means zero, undefined, or the empty string):
    $a ||= 5;
    $a = $a || 5;           # another way
    $a = 5 unless $a;       # another way


Difference b/w undef and empty string
    An empty string, is a string defined to be empty. It is defined. Creating a scalar variable without assigning it anything 
    or assigning it the special symbol undef are two ways of saying "I haven't chosen a value yet. Act accordingly."
        my $a;                      defined($a); returns false.
        my $a=undef;                defined($a); returns false.
        my $a='';                   defined($a); returns true.
        my $a="";                   defined($a); returns true.
        my $a=1; $a=undef;          defined($a); returns false.
        print 3 + undef;            # 3
        print "hello" . undef       # hello
        $a=undef;  print $b=()=(9,15,$a);         # 3  


Length function on an undefined value
    In Perl 5.12, it's a bit easier because length on an undefined value also returns undefined. 
    That doesn't issue a warning, which is the reason this question exists.

    use 5.012;
    use warnings;

    my $name;

    if( length $name ) { # no warning
        ...
        }



goatse operator "  = () =  "
    my $str = "here are some words";
    my $count = () = $str =~ /\S+/g;

    The "empty parentheses" idiom is one that is used to force list context on an expression, 
    and yet return a scalar: the count of items in that list.


Baby cart sign @{[ ]}
    Discovered by Larry Wall, 1994. (Alternate nicknames: "shopping-trolley", "pram", "turtle")
        print "sorted array: @{[ sort keys %hash ]} \n";
    
    Another use case is for breaking aliasing (i.e. make a copy); for example to 
    avoid the Modification of a read-only value attempted fatal error when running such code:
        for (qw( 1 2 3 )) {
            $_ = $_ * $_;    # contrived, error!
            print "square: $_\n";
        }
    With the babycart, the topic is an actually modifiable copied scalar.
        for ( @{[ qw( 1 2 3 ) ]} ) {
            $_ = $_ * $_;    # contrived, OK!
            print "square: $_\n";
        }


Schwartzian transform
    It is a technique used to improve the efficency of sorting a list of items. The idiom is named after Randal L. Schwartz,
    who first demonstrated it in Perl 5 in 1994. It has been later adpoted by other languages such as Python, Ruby, PHP, etc.
    The term "Schwartzian transform" indicates a specific idiom, and not the algorithm in general.
    [ See "Schwartzian transform" in Wikipedia ]

'$::foo' and '@::foo'
    They are shorthand for '$main::foo' and '@main::foo'.
    
    The default namespace, main, is an alias for the root namespace.
    Most "global" variables are actually package-globals, meaning they are global within package in which
    they are defined. In modern Perl, these vairiables are typically accessed in other packages via suitable
    our declarations, bute the older mechanism of use vars is still available.    
    

Dummy placeholder
    our ( undef, $min, $hour ) = localtime;


our 
    our makes a lexical alias to a package variable of the same name in the current package for use within
    the current lixical scope.
    Notes:
    [1] It only valid wthin a lexical scope.
    [2] It only reates an alias to an existing varaibles ( a package variable of the same name )
    [3] It works even if the pacakge variable has not been used before, as package varaibles sprint into
    existence when first used.
    [4] Multiple our declarations with the same name in the same lexical scope are allowd if they are
    in different packages. If they are in the smae package, Perl will emit warnings as the second is 
    merely redundant.
    ---------------------------------------------------------
    package Foo;
    use strict;
    
    $Foo::foo = 23;
    {
        our $foo;       # Alias to $Foo::foo
        print $foo;     # Prints 23
    }
    print $Foo:foo;     # Prints 23
    print $foo;         # ERROR: requires explicit package name
    ---------------------------------------------------------


"our" vs "use vars"
    use vars: allows use of an unqualified name only whtin the affected package, but across scopes.
    our:  An our declaration declares an alias for a package variable that will be visible across its
    entire lexical scope, even across package boundaries. The package in which the variable is entered is
    determined at the point of the decalaration, not at the piont of use.
    ---------------------------------------------------------
    package Foo;
    our $bar;       # Declares $Foo:bar for rest of lexical scope
    $bar = 20;
    
    package Bar;
    print $bar;     # Prints 20, as it referes to $Foo::bar    
    ---------------------------------------------------------    

Function Scope
    Function declarations are global in Perl. 
    
    
Two ways of using stastic variables    
    The first mothod is to use stat variable.
    ---------------------------------------------------------
    use strict;
    use warnings;
    use 5.010;
    
    sub count {
        state $counter = 0;
        $counter++;
        return $counter;
    }
    say count();       # Prints 1
    say count();       # Prints 2
    say count();       # Prints 3
    ---------------------------------------------------------    
    
    The second method is to use my and block.
    ---------------------------------------------------------
    use strict;
    use warnings;
    use 5.010;
    
    {
        my $counter = 0;
        sub conut {
            $counter++;
            return $counter;
            }
    }
    say count();       # Prints 1
    say count();       # Prints 2
    say count();       # Prints 3
    ---------------------------------------------------------

PDO
    A Pod bolock starts with ANY command paragraph, so a "=pod" command is usually just when you want to start a Pod block with
    and ordinary paragraph or verbatim paragraph.
    To end a Pod block, use a blank line, then a line beginning with "=cut", and a blank line after it.
    
    
-> operator
    "->" is an infix derefence operator, just as it is in C an C++. 
    If the right side if either a [...], {...}, or a (...) subscript, then the left side must be either
    a hard or symbolic reference to an array, a hash, or a subroutine respectively. (Or technically speaking,
    a location capable of holding a hard reference, if it's an array or hash reference being used for assignment.)
    
    Otherwise, the right side is method name or a simple scalar variable containing either the method name or
    a subroutine reference, and the left side must be either an object(a blessed reference) or a class name
    (that is, a package name).
    
+shift
    Unary plus is a NOP. It prevents ffrom what follows being interpreted as a bareword, and hence, from
    being autoquoted.    
    This is a just a way to disambiguating the shift in a location where it might be mistaken
    for another lexical item such as:
        print +join ' ', @array;


Quick multi-line comment
    Labeling the comments begins with '=begin comment', then uses '=end comment', then ends with '=cut'.
    -----------------------------------
    =begin comment
    
    my $str = "hello";
    print $str, "\n";
    
    =end comment
    
    =cut

    -----------------------------------
    
    
Bareword hash keys
    A bareword generally refers to a sequence of characters that is suitable for an identifier(i.e. A-Za-z_A-Za-z_0-9).
    The strict pragma bans most uses of barwords by default, but they still live on 
    [1] the names of global filehandles
    [2] things that are auto-quoted by the fat comma operator.
        example:  my %h = ( nanme => 'Foo');
    [3] keys that don't require quoting in hashes
        example:  print $h{name}, "\n";                
    In the latter two cases the set of allowed characters includes a leading hyphen '-'.
    
    Perl by default allows barewords--words without quotes--to behave like strings. For example:    
        my $x = hello;
        print "$x\n";           # Prints "hello"
    This is a bad example, "use strict;" alwayes.   
  
    The "pinball" in "$games{pinball}" will be identify as string keys.
    If you want to a builtin or a function to produce the hask key, you should use function argument parentheses,
    or prepend unary plus to force the evaluation of the builtin.
            # the literal 'shift' is the key
            my $value = $items{shift};
            
            # the value produced by shift is the key
            my $value = $items{shift @_};
            
            # unary plus uses the builtin shift
            my $value = $items{+shift};
            
    Without the * sigil, a bareword is just a string.  
            


Dispatch tables of coderefs
    from: https://www.xaprb.com/blog/2006/10/05/five-great-perl-programming-techniques-to-make-your-life-fun-again/
    What exactly is a dispatch table? It’s a hash of references to executable code. 
    -----------------------------------------------------------------
    #!/usr/bin/perl

    use strict;
    use warnings FATAL => 'all';

    use Term::ReadKey;

    sub display_a {
       print "I am in display_a\n";
    }

    sub display_b {
       print "I am in display_b\n";
    }

    my $dispatch_for = {
       a => \&display_a,
       b => \&display_b,
       q => sub { ReadMode('normal'); exit(0) },
    };

    while ( 1 ) {
       print "Press a key!\n";
       ReadMode('cbreak');
       my $char = ReadKey(10);
       defined $dispatch_for->{$char} && $dispatch_for->{$char}->();
    }

    -----------------------------------------------------------------
    my $dispatch_for = {
       a => \&display_a,
       b => \&display_b,
       q => sub { ReadMode('normal'); exit(0) },
       DEFAULT => sub { print "That key does nothing\n"; },
    };

    # Later
       my $func = $dispatch_for->{$char} || $dispatch_for->{DEFAULT};
       $func->();    
    -----------------------------------------------------------------
    
    
    
