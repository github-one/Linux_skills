our 
    our makes a lexical alias to a package variable of the same name in the current package for use within
    the current lixical scope.
    Notes:
    [1] It only valid wthin a lexical scope.
    [2] It only reates an alias to an existing varaibles ( a package variable of the same name )
    [3] It works even if the pacakge variable has not been used before, as package varaibles sprint into
    existence when first used.
    [4] Multiple our declarations with the same name in the same lexical scope are allowd if they are
    in different packages. If they are in the smae package, Perl will emit warnings as the second is 
    merely redundant.
    ---------------------------------------------------------
    package Foo;
    use strict;
    
    $Foo::foo = 23;
    {
        our $foo;       # Alias to $Foo::foo
        print $foo;     # Prints 23
    }
    print $Foo:foo;     # Prints 23
    print $foo;         # ERROR: requires explicit package name
    ---------------------------------------------------------


"our" vs "use vars"
    use vars: allows use of an unqualified name only whtin the affected package, but across scopes.
    our:  An our declaration declares an alias for a package variable that will be visible across its
    entire lexical scope, even across package boundaries. The package in which the variable is entered is
    determined at the point of the decalaration, not at the piont of use.
    ---------------------------------------------------------
    package Foo;
    our $bar;       # Declares $Foo:bar for rest of lexical scope
    $bar = 20;
    
    package Bar;
    print $bar;     # Prints 20, as it referes to $Foo::bar    
    ---------------------------------------------------------    

Function Scope
    Function declarations are global in Perl. 
    
    
Two ways of using stastic variables    
    The first mothod is to use stat variable.
    ---------------------------------------------------------
    use strict;
    use warnings;
    use 5.010;
    
    sub count {
        state $counter = 0;
        $counter++;
        return $counter;
    }
    say count();       # Prints 1
    say count();       # Prints 2
    say count();       # Prints 3
    ---------------------------------------------------------    
    
    The second method is to use my and block.
    ---------------------------------------------------------
    use strict;
    use warnings;
    use 5.010;
    
    {
        my $counter = 0;
        sub conut {
            $counter++;
            return $counter;
            }
    }
    say count();       # Prints 1
    say count();       # Prints 2
    say count();       # Prints 3
    ---------------------------------------------------------

PDO
    A Pod bolock starts with ANY command paragraph, so a "=pod" command is usually just when you want to start a Pod block with
    and ordinary paragraph or verbatim paragraph.
    To end a Pod block, use a blank line, then a line beginning with "=cut", and a blank line after it.
    
    
-> operator
    "->" is an infix derefence operator, just as it is in C an C++. 
    If the right side if either a [...], {...}, or a (...) subscript, then the left side must be either
    a hard or symbolic reference to an array, a hash, or a subroutine respectively. (Or technically speaking,
    a location capable of holding a hard reference, if it's an array or hash reference being used for assignment.)
    
    Otherwise, the right side is method name or a simple scalar variable containing either the method name or
    a subroutine reference, and the left side must be either an object(a blessed reference) or a class name
    (that is, a package name).
    
+shift
    Unary plus is a NOP. It prevents ffrom what follows being interpreted as a bareword, and hence, from
    being autoquoted.    
    This is a just a way to disambiguating the shift in a location where it might be mistaken
    for another lexical item such as:
        print +join ' ', @array;


Quick multi-line comment
    Labeling the comments begins with '=begin comment', then uses '=end comment', then ends with '=cut'.
    -----------------------------------
    =begin comment
    
    my $str = "hello";
    print $str, "\n";
    
    =end comment
    
    =cut

    -----------------------------------
    
    
Bareword hash keys
    A bareword generally refers to a sequence of characters that is suitable for an identifier(i.e. A-Za-z_A-Za-z_0-9).
    The strict pragma bans most uses of barwords by default, but they still live on 
    [1] the names of global filehandles
    [2] things that are auto-quoted by the fat comma operator.
        example:  my %h = ( nanme => 'Foo');
    [3] keys that don't require quoting in hashes
        example:  print $h{name}, "\n";                
    In the latter two cases the set of allowed characters includes a leading hyphen '-'.
    
    Perl by default allows barewords--words without quotes--to behave like strings. For example:    
        my $x = hello;
        print "$x\n";           # Prints "hello"
    This is a bad example, "use strict;" alwayes.   
  
    The "pinball" in "$games{pinball}" will be identify as string keys.
    If you want to a builtin or a function to produce the hask key, you should use function argument parentheses,
    or prepend unary plus to force the evaluation of the builtin.
            # the literal 'shift' is the key
            my $value = $items{shift};
            
            # the value produced by shift is the key
            my $value = $items{shift @_};
            
            # unary plus uses the builtin shift
            my $value = $items{+shift};
            
    Without the * sigil, a bareword is just a string.  
            

        
