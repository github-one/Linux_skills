$#ARGV
    The special variable $#array tells you the index of the last element of an array(that means n-1).
    If you pass 0 arguments, $#ARGV will be -1, since there are no elements in the array.
    If you pass 1 argument, $#ARGV will be 0.
    
    $perl -E 'say for @ARGV' file1 file2
    file1
    file2
    
    Be careful if your arguments start with a hyphen, e.g. the -file1 and -file2. Perl will take it as an option.
    $perl -E 'say for @ARGV' -file1 -file2
    -i used with no filenames on th command line, reading from STDIN.
    They look like option(to both Perl and humans). Seperate options and other(non-option)arguments with '--'
    $perl -E 'say for @ARGV' -- -file1 -file2
    -file1
    -file2
    
$0 and @ARGV
    The name of the program being executed is always in the $0 variable of Perl. (but $1, $2, etc are note related)
    
    C prgrogram: the name of the program being executed is in argv[0], the number of arguments is argc.
    
    Unix/Linux shell program: $0 is the name of the script being executed. $1, $2, etc. hold the rest of the commmand
    line parameters.
    
    Extract the command line argumets from @ARGV
    my ($name, $number) = @ARGV;
    if (not defined $name) { die "Nedd name\n" }
    ...
    
    my $filename = shift or die "usage: $0 FILENAME\n";
    # There is on minor bug in the above code. If the user supplies '0' as the name of the file. 
    But it doesn't matter, since we can live with the fact. 
    
Getopt::Long
    "Long" is relatvie here, it just means more than one character.
    
    Types of the command line arguments:
        -Long name with values
        -Long name without value: We would accept flags by their mere existence.
        -Short name(or single-character names) with values
        -Short name without value
        -combining short names, -vd should be understood as -v -d. The difference here is that "long names"
            start with double-dash "--" while short names, even if several of them were combined together
            start with a single dash "-".
        - Non-affiliated values, values without any name starting with a dash in front of them.

    ##################  test.pl #############################################################
    #!/usr/bin/perl
    use strict;
    use 5.010;
    use Getopt::Long qw(GetOptions);
    
    my ($trace, $machine) = (0);
    GetOptions(
            'machine'             => \$machine,
            'trace=i'             => \$trace,
    ) or die "Usage: $0 [--trace NUMBER] [--machine NAME]\n";

    if (defined $machine) {
            say $machine;
    } else {
            say 'undef';
    }
    say $trace;
    say join ", ", $0, @ARGV;   
    ##########################################################################################
    
    Input and output (note: "/" stands for a new line)
        perl test.pl                            =>  undef/0/test.pl
        perl test.pl --machine                  =>  1/0/test.pl
        perl test.pl --machine --trace 3        =>  1/3/test.pl
        perl test.pl --machine --trace          =>  Option trace requires an argument/Usage: ...
        perl test.pl --ma --tr 3                =>  1/3/test.pl
        perl test.pl --m --t 3                  =>  1/3/test.pl
        perl test.pl -m -t 3                    =>  1/3/test.pl
        perl test.pl -m -tr 3                   =>  1/3/test.pl
        perl test.pl -m --tr 3                  =>  1/3/test.pl
        perl test.pl -m --tr=3                  =>  1/3/test.pl
        perl test.pl -m -t=3                    =>  1/3/test.pl
        
        perl test.pl -mt 3                      =>  Unknown option: mt/Usage: ...
        perl test.pl -mt3                       =>  Unknown option: mt3/Usage: ...
        perl test.pl -m -t3                     =>  Unknown option: t3/Usage: ...

        perl test.pl -m -t 3 hello              =>  1/3/test.pl, hello
        perl test.pl -m -t 3 one two            =>  1/3/test.pl, one, two
        perl test.pl -m -one                    =>  Unknown option: o/.../.../Usage: ...
        perl test.pl -m -- -one                 =>  1/0/test.pl, -one        
        
        Note: --machine or -m flag will set $machine value to "true".
        
Non-affiliated values
    The GetOptions function only handles the parameters that start with a dash and their corresponding values,
    when they are relevant. Once it processed the options it will remove them from @ARGV. (Both the option name
    and the option value will be removed.) Any other, non-affiliated values on the command line will stay
    in @ARGV.
   
        
Single-character and bundling feature
    ##################  test.pl #############################################################
    ...
    Getopt::Long::Configure("bundling");
    ...        
    GetOptions(
            'machine|m'             => \$machine,
            'trace|t=i'             => \$trace,
    ) or ...
    ...
    ##########################################################################################        
        
    Input and output (note: "/" stands for a new line)
        perl test.pl --m --t 3                  =>  1/3/test.pl  
        perl test.pl -m -t 3                    =>  1/3/test.pl
        perl test.pl -m -t3                     =>  1/3/test.pl
        perl test.pl -mt3                       =>  1/3/test.pl
        perl test.pl -mt 3                      =>  1/3/test.pl
        
        perl test.pl -m -t=3                    =>  Unknown option: =/Unknown option: 3/Usage: ...
        perl test.pl -mt                        =>  Option t requires an argument/Usage: ...
        perl test.pl -mtr                       =>  Value "r" invalid for option t (number expected)/Usage: ...
        
        
Negatable boolean arguments
    Negatable boolean argument is the exclamation mark "!" at the end of the flag.
    
    my $verbose;
    GetOptions( 'verbose!' => \$verbose);
    
    Input and output
        (none input)    =>      $verbose is undef
        --verbose       =>      $verbose is 1
        --noverbose     =>      $verbose is 0
        --nove          =>      $verbose is 0
        --nov           =>      $verbose is 0
        -noverbose      =>      error
        --nov --ver     =>      $verbose is 1

Optional value
    Using :s at the end of the option name.
    GetOptions( 'logfile:s' => \$logfile);

        
Regular expression for the commmand line    
    while (@ARGV && ($_ = $ARGV[0]) =~ /^-(.)(.*)/) { ... }
    # This regex will match things like "-a", "-abc", but it won't match "--xzy" or "abc".
    
    my (@witharg)   = ($args =~ /(\S)\s*:/g);
    my (@rest)      = ($args =~ /([^\s:])(?!\s*:)/g);
    
    #If $args ='a:b :cde: +:-', the @witharg will be ('a','b','e','+'), the @rest will be ('c','d','-').
    #The group (?!\s*:) is a zero-width negative look-ahead assertion.
    
    
    
    
        
        
        
