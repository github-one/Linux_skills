
-X FILEHANDLE

    $str = "/some/file/location/";
    if ( -d $str ) {
        print "This is a directory.\n";
    }
    
    -r  File is readable by effective uid/gid.
    -w  File is writable by effective uid/gid.
    -x  File is executable by effective uid/gid.
    
    -e  File exists.
    -z  File has zero size (is empty).
    -s  File has nonzero size (returns size in bytes).

    -f  File is a plain file.
    -d  File is a directory.
    -l  File is a symbolic link (false if symlinks aren't supported by the file system).
    -p  File is a named pipe (FIFO), or Filehandle is a pipe.
    -S  File is a socket.
    -b  File is a block special file.
    -c  File is a character special file.
    -t  Filehandle is opened to a tty.

Directory operations
    $mydir = "/root/mypath/*";      # note: "/root/mypath" will get only one result.
    my @files = glob( $mydir );
    print join "\n", @files;        # note: the result is sorted.  
    
    opendir (DIR, "/root/mypath") or die "Error, $!";       # note: "/root/mypath" vs "/root/mypath/*"
    @files = readdir DIR;
    print join "\n", @fiels;        # note: the result is unsorted and includes hidden files.

File::Find

    use File::Find;
    my $dir = "/root/mypath";
    find(sub { print if -d }, $dir);
    find(sub { print $FILE::Find::name if -d}, $dir);
       
    # print the 10 largest files found in the tree under the directory
    #---------------------------------------------------------------------------
    #!/usr/bin/perl -w
    
    ($#ARGV == 0) or die "Usage: $0 [directory]\n";
    
    use File::Find;
    
    find(sub { -l && return; $size{$File::Find::name} = -s if -f;}, @ARGV);
    @sorted = sort {$size{$b} <=> $size{$a}} keys %size;
    
    splice @sorted, 10 if @sorted > 10;
    
    foreach (@sorted)
    {        
        printf "%10d %s\n", $size{$_}, $_;
    } 
    #---------------------------------------------------------------------------
        
    
    use File::Find::Rule;
    my $dir = "/root/mypath";
    for my $file (File::Find::Rule->in($dir)) {
        print $file . "\n";
    }
    
    use File::Find::Rule;
    # find all the subdirectories of a gvie directory
    my @subdir = File::Find::Rule->directory->( $directory );
    
    # find all the .pm files in @INC
    my @files = File::Find::Rule->file()
                                ->name( '*.pm' )
                                ->in( @INC );
                                
    # find all the .pm file in @INC, but without method chaining
    my $rule = File::Find::Rule-new;
    $rule->file;
    $rule->name( '*.pm' );
    my @files = $rule-in( @INC );
    
    
File path separator
    Different Operating Systems sue different characters as their path separator:
    foo/bar/baz     # *nix
    foo\bar\baz     # Windows
    foo:bar:baz     # Mac OS 9
    foo/bar/baz     # Mac OS X
    
    In Perl you can generally just use a '/' as your path separtor( except on MAC OS 9 ?) because Perl will automagically convert 
    the '/' to the correct path separator for the system it is running on.
    
$#ARGV
    The special variable $#array tells you the index of the last element of an array(that means n-1).
    If you pass 0 arguments, $#ARGV will be -1, since there are no elements in the array.
    If you pass 1 argument, $#ARGV will be 0.
    
    
