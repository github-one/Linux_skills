re 'debug' pragma
        use re 'debug';  
    The use re 'debug' pragma comes with Perl 5.005 and later. You can watch Perl's regular expression engine at work
    to verify for yourself if Perl is recompiling a regular expression.
  
Regex for array
        WRONG: @file =~ s/find/replace/; 
        The left side of the regex binding operator imposes scalar context on its arguments. An array in scalar context
        returns its length, but this value is read only.
        
        foreach my $line (@file) { $line =~ s/find/replace/ }
        s/find/replace/ for @file;         # More succinctly
        
        my @array = ("foo {abc123}", "bar {def456}", "car {ghi789}");
        my @patterns = ("foo", "bar", "tar");
        my $regex = jion '|', @patterns;            # or: my $regex = join '|', map quotemeta, @array    
        foreach my $i (@array) {
            if ($i =~ m/$regex/) {
                print "$i is in array\n";
            }
            ...
        }   
        
        
Regex for file
        open my $fh, '<', $ARGV[0] or die "Open error: $!";
        my $file = do { local $/;  <$fh> };
        ...

/O option
    The /o option for regular expression tells Perl to complie the regular expression only once.
    This is only usefule when the pattern contains a variable. Perl 5.6 and later handle this automatically if
    the patter does not change. So, you don't need the /o option. It doesn't hurt, but it doesn't help either.
    
    
Comments Regex
    Regexp::Common - Provide commonly requested regular expressions
    Regexp::Common::comment -- provide regexes for comments.
    
Regex explanation
    use YAPE::Regex::Explain;
    my $exp = YAPE::Regex::Explain->new($REx)->explain;        
    Note: There is no support for regular expression syntax added after Perl version 5.6, particularly any constructs added in 5.10.

How can I quote a variable to use in a regex?
    The Perl parser will expand $variable and @variable references in regular expressions unless the delimiter is a single quote. 
    The [right-hand side] of a s/// substitution is considered a double-quoted string.
    Remember that ANY regex special characters will be acted on unless you precede the substitution with \Q. 
    
        $string = "Placido P. Octopus";
        $regex  = "P.";

        $string =~ s/$regex/Polyp/;
        # $string is now "Polypacido P. Octopus"
        
        $string =~ s/\Q$regex/Polyp/;
        # $string is now "Placido Polyp Octopus"

Matching multiple lines
        /s allows dot to include newline. (normally it doesn't)
        /m allows caret and dollar to match next to a newline, not just at the end of the string.
        
        
---------------------------------------------- Special Charaters --------------------------------------------------- 
    \w        [3]  Match a "word" character (alphanumeric plus "_", plus
                                      other connector punctuation chars plus Unicode
                                      marks)
    \W        [3]  Match a non-"word" character
    \s        [3]  Match a whitespace character
    \S        [3]  Match a non-whitespace character
    \d        [3]  Match a decimal digit character
    \D        [3]  Match a non-digit character
    \pP       [3]  Match P, named property.  Use \p{Prop} for longer names
    \PP       [3]  Match non-P
    \X        [4]  Match Unicode "eXtended grapheme cluster"
    \1        [5]  Backreference to a specific capture group or buffer.
                                      '1' may actually be any positive integer.
    \g1       [5]  Backreference to a specific or previous group
    \g{-1}    [5]  The number may be negative indicating a relative
                                      previous group and may optionally be wrapped in
                                      curly brackets for safer parsing.
    \g{name}  [5]  Named backreference
    \k<name>  [5]  Named backreference
    \K        [6]  Keep the stuff left of the \K, don't include it in $&
    \N        [7]  Any character but \n.  Not affected by /s modifier
    \v        [3]  Vertical whitespace
    \V        [3]  Not vertical whitespace
    \h        [3]  Horizontal whitespace
    \H        [3]  Not horizontal whitespace
    \R        [4]  Linebreak

zero-width assertions
     \b{}   Match at Unicode boundary of specified type
     \B{}   Match where corresponding \b{} doesn't match
     \b     Match a \w\W or \W\w boundary
     \B     Match except at a \w\W or \W\w boundary
     \A     Match only at beginning of string
     \Z     Match only at end of string, or before newline at the end
     \z     Match only at end of string
     \G     Match only at pos() (e.g. at the end-of-match position
            of prior m//g)
            
            
